/*
	D issubset of {1,2,3,4,5,6,7,8,9}
	eg. D = {1,3,5,7} , N = 100
	return 20 
	as we have 1,3,5,7,11,13,15,17,31,33,35,37,51,53,55,57,71,73,75,77
*/

class Solution {
public:

	int hasEqn(string s,vector<string>& D,int i){
		int n = 0;
		for(auto &x: D)
			for(int j = 0; j < x.size(); j++) //for all digits in D
				if(x[j] == s[i]) ++n; //increment n if this digit is equal to s[i]
		return n;
	}

	int countLess(string s,vector<string>& D,int i){
		int n = 0;
		for(auto &x: D)
			for(int j = 0; j < x.size(); j++) //for all digits in D
				if(x[j] < s[i]) ++n; //increment n if this digit is less than s[i]
		return n;
	}

	int f(string s, vector<string>& D, int m){
		if(m < 0)
			return 0;
		if(m >= s.size())
			return 0;

		int less = countLess(s,D,m);
		int eq = hasEqn(s,D,m);

		if(eq > 0){
			if(m < s.size() - 1)
				return less*pow(D.size(),s.size() - m - 1) + f(s,D,m+1);
			return less + 1;
		}
		return less*pow(D.size(),s.size() - m - 1);
	}

    int atMostNGivenDigitSet(vector<string>& D, int N) {
    	if(N == 0)
    		return 0;

        string s = to_string(N);
        int digits_used = 1;
        int num = 0; // |D|+|D|^2+...+|D|^(i-1)
        int now = 1; // |D|^i

        for(digits_used = 1; digits_used < s.size(); digits_used++){
        	now *= D.size();
        	num += now;
        }
        // digits_used = #(digits in N)
        // now lets count the numbers created with exactly #(N) digits.
        num += f(s,D,0);
        return num;
    }
};
/*	
	given that D does not contain 0

	dealing with integers is disgusting, so we deal with strings.
	convert N to string, say it has n digits.
	
	we observe a pattern:
	for numbers that we generated by using digits in D, if this 
	number has k digits, where 1<=k<n. Then there are |D|^k such number.

	for k = n it is more complicated
    let f(s,D,i) be the #(numbers from less than N)
    we obtain the recursion:
    f(s,D,i) = numLess * |D|^(|s|-i-1) + hasEqn * f(s,D,i+1)

    The rest is easy
*/